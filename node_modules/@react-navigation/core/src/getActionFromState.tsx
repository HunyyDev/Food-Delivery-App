import type {
  CommonActions,
  NavigationState,
  ParamListBase,
  PartialRoute,
  PartialState,
  Route,
} from '@react-navigation/routers';

import type { NavigatorScreenParams, PathConfig, PathConfigMap } from './types';

type ConfigItem = {
  initialRouteName?: string;
  screens?: Record<string, ConfigItem>;
};

type Options = {
  initialRouteName?: string;
  screens: PathConfigMap<object>;
};

type NavigateAction<State extends NavigationState> = {
  type: 'NAVIGATE';
  payload: {
    name: string;
    params?: NavigatorScreenParams<State>;
    path?: string;
  };
};

export default function getActionFromState(
  state: PartialState<NavigationState>,
  options?: Options
): NavigateAction<NavigationState> | CommonActions.Action | undefined {
  // Create a normalized configs object which will be easier to use
  const normalizedConfig = options
    ? createNormalizedConfigItem(options as PathConfig<object> | string)
    : {};

  const routes =
    state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;

  if (routes.length === 0) {
    return undefined;
  }

  if (
    !(
      (routes.length === 1 && routes[0].key === undefined) ||
      (routes.length === 2 &&
        routes[0].key === undefined &&
        routes[0].name === normalizedConfig?.initialRouteName &&
        routes[1].key === undefined)
    )
  ) {
    return {
      type: 'RESET',
      payload: state,
    };
  }

  const route = state.routes[state.index ?? state.routes.length - 1];

  let current: PartialState<NavigationState> | undefined = route?.state;
  let config: ConfigItem | undefined = normalizedConfig?.screens?.[route?.name];
  let params = { ...route.params } as NavigatorScreenParams<
    ParamListBase,
    NavigationState
  >;

  let payload = route
    ? { name: 